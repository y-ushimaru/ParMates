/********************************************************************
 Copyright (C) 2002-2014 Shinobu Yoshimura, University of Tokyo,
 the Japan Society for the Promotion of Science (JSPS)
 All Rights Reserved
 *********************************************************************/
/* autogl_graphics_software.c : software emulation */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

#include "autogl_os.h"
#include "autogl_math.h"
#include "autogl_uims.h"
#include "autogl_uims_inside.h"
#include "autogl_graphics.h"
#include "autogl_graphics_inside.h"

#ifdef AUTOGL_MP
#include "autogl_com_inside.h"
#endif

#include "autogl_callback_inside.h"
#include "autogl_graphics_software_inside.h"



/* Thanks to Mr. Ookubo in Allied Engineering */
/* for his initial trial implementation */

/* Thanks to Mr. Tatsuhiro Hirano in Yoshimura lab. */
/* for his font implementation */



/* Module Variables */

/* background color of the view window */
static double View_backgroundRed;
static double View_backgroundGreen;
static double View_backgroundBlue;

static double View_selectionModeFlag;
static int View_selectionScX;
static int View_selectionScY;
static int View_selectionRange;
static int View_currentSelectionId;
static int View_selectedId;
static double View_selectedScZ;


/* ウインドウサイズ */
#define  SCREEN_X 500
#define	 SCREEN_Y 500

/* Ｚバッファの定義 */
static double ZBuffer[MAX_IMAGE_HEIGHT][MAX_IMAGE_WIDTH];
static unsigned char ColorBuffer[MAX_IMAGE_HEIGHT][MAX_IMAGE_WIDTH][3];  

/* current color components */
static double CurrentRed;
static double CurrentGreen;
static double CurrentBlue;

static int ImageWidthSc = SCREEN_X;
static int ImageHeightSc = SCREEN_Y;

/*
　　標準座標
   
   y
   |
   |
   |
   |
   |_____________x
		(0,0)

　　スクリーン座標
   
  (0,0)
    --------------> y
    |
    |
    |
    |
    x 
*/


/* 
  3次元の配列でカラーデータを構成する

    ----------------　 ex)
   | (0,1) | (1,1) |   RGB-0 : 000
   | RGB-2 | RGB-3 |   RGB-1 : 100
   |---------------|   RGB-2 : 010
   | (0,0) | (1,0) |   RGB-3 : 110
   | RGB-0 | RGB-1 | 
    ---------------    
  
   y
   |
   |
   ----->x
--------------------------------------------------
  1次元の配列でイメージ(ppm)座標系でデータ出力
　RGB-2 --> RGB-3 --> RGB-0 --> RGB-1
  010       110       000       100
  
  
   ---->x
   |
   |
   y

   RGB(1Byte * 3)

  <RGB Exsample>
          R     G    B
   White 255   255  255
   Red   255   000  000
   Green 000   128  000
   Blue  000   000  255
   Black 000   000  000
*/



#define autogl_font_width 114
#define autogl_font_height 112
static char autogl_font_bits[] = {
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,
 0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x01,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,
 0x00,0x00,0x00,0x05,0xa1,0x00,0x00,0x60,0x06,0x00,0x00,0x00,0x00,0x80,0x00,
 0x00,0x08,0x0b,0x89,0xed,0xa0,0x30,0x60,0x06,0x06,0x00,0x00,0x00,0xc0,0x00,
 0x00,0x18,0x9b,0xc5,0xbf,0xf1,0x71,0x30,0x04,0x17,0x00,0x00,0x00,0xc0,0x00,
 0x00,0x18,0xca,0x7f,0xe4,0x35,0x20,0x10,0x8c,0x3f,0x02,0x00,0x00,0x60,0x00,
 0x00,0x08,0xdb,0xdf,0xc1,0x37,0x20,0x30,0x08,0x0e,0x02,0x00,0x00,0x60,0x00,
 0x00,0x08,0x0a,0x85,0xf7,0x71,0x27,0x10,0x0c,0x5f,0x0b,0xe0,0x03,0x30,0x00,
 0x00,0x08,0xc0,0x5d,0xa4,0xdb,0x03,0x30,0x08,0xca,0x1f,0xa0,0x02,0x30,0x00,
 0x00,0x08,0x80,0x6f,0xcc,0xd2,0x01,0x20,0x0c,0x00,0x02,0x01,0x40,0x10,0x00,
 0x00,0x1c,0x80,0xe4,0xc7,0xfb,0x07,0x30,0x0c,0x00,0x82,0x01,0xe0,0x18,0x00,
 0x00,0x08,0x80,0x45,0x01,0x51,0x02,0x60,0x06,0x00,0x82,0x01,0x40,0x18,0x00,
 0x00,0x00,0x80,0x04,0x01,0x00,0x00,0x60,0x06,0x00,0xc0,0x00,0x00,0x0c,0x00,
 0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x38,0x0e,0x8f,0x07,0xe3,0xe3,0xfb,0x7c,0x3e,0x00,0x00,0x00,0x00,0xf8,0x00,
 0x6c,0x9d,0x99,0x8c,0x23,0x70,0x8c,0x6d,0x36,0x00,0x00,0x00,0x00,0xcc,0x00,
 0x44,0x08,0x10,0x84,0x23,0x10,0x80,0x46,0x23,0x00,0x00,0x04,0x10,0x88,0x01,
 0xc6,0x18,0x18,0xce,0xe2,0xb3,0xc0,0x7c,0x62,0x0c,0x07,0x57,0x71,0xc0,0x00,
 0x44,0x08,0x0c,0x6f,0xa3,0xfb,0xc1,0x7c,0x3e,0x0e,0xc6,0xa3,0xc2,0x73,0x00,
 0xc6,0x18,0x06,0xe8,0x0f,0x16,0x61,0xc4,0x68,0x00,0xe0,0xd0,0x82,0x13,0x00,
 0x44,0x18,0x13,0x08,0x03,0x1a,0x63,0xc6,0x30,0x04,0xc2,0xf3,0xe7,0x21,0x00,
 0x7c,0xff,0xdf,0x8f,0xff,0xf3,0x21,0x7c,0x1e,0x0e,0x03,0x0f,0x70,0x70,0x00,
 0x28,0x2a,0x15,0x05,0x45,0xa1,0x20,0x28,0x0a,0x04,0x03,0x00,0x10,0x20,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x28,0xdf,0x9f,0xff,0xf7,0xff,0xff,0xef,0x7f,0xfe,0xfd,0x3b,0x9e,0xff,0x00,
 0xdc,0x1c,0x99,0x79,0x2e,0x34,0x8e,0xc7,0x08,0x90,0x4c,0x70,0x37,0x8d,0x01,
 0xa2,0x9c,0xf1,0x70,0x28,0x95,0x86,0x47,0x08,0x98,0x87,0x70,0x3f,0x0e,0x01,
 0xfb,0x36,0xdb,0x70,0x78,0xf1,0x05,0xed,0x08,0x90,0x47,0xf0,0x6f,0x07,0x03,
 0x2a,0xa7,0x7f,0x40,0xf8,0xf1,0x86,0x7e,0x88,0x98,0x87,0xf8,0x57,0x07,0x03,
 0xff,0x7f,0xf1,0x60,0x28,0xb5,0xc5,0xc7,0x88,0x90,0x4c,0xd8,0xce,0x07,0x01,
 0xfa,0xe3,0xf1,0x60,0x2c,0x34,0x8c,0xc7,0x88,0x98,0x8d,0xb8,0x96,0x8f,0x01,
 0xee,0xf7,0xbf,0xff,0xf7,0xff,0xf8,0xef,0xff,0xcf,0xfb,0x3f,0x3e,0xfb,0x00,
 0xa8,0x42,0x15,0xaa,0x52,0x55,0xa0,0xaa,0x2a,0x4a,0xa1,0x2a,0x2a,0x51,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0xe0,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5e,0xf0,0xe0,0x00,0x00,
 0x7e,0xfe,0x9f,0xff,0x7f,0xbf,0xdf,0xef,0xf7,0x3f,0xc4,0x40,0xb0,0x01,0x00,
 0xe4,0x63,0xb9,0x39,0x39,0x1e,0x27,0x65,0x62,0x31,0xc2,0x80,0x10,0x01,0x00,
 0x88,0x43,0xd1,0x38,0x39,0x1c,0xef,0x3d,0xb6,0x19,0x84,0x40,0x00,0x00,0x00,
 0x84,0x41,0xb9,0x23,0x19,0x36,0x6d,0x39,0x1c,0x0d,0x82,0x81,0x00,0x00,0x00,
 0xf8,0xc1,0x9f,0x0f,0x31,0xb4,0xf9,0x38,0x1c,0x06,0x04,0x41,0x00,0x00,0x00,
 0x2c,0xc1,0x4d,0x18,0x21,0xa6,0xdd,0x2d,0x08,0x26,0x02,0x83,0x00,0x00,0x00,
 0x08,0x63,0xd9,0x18,0x31,0xe6,0xd8,0x6d,0x08,0x33,0x04,0x42,0x00,0x00,0x00,
 0x3e,0xfe,0xf3,0xdf,0xe7,0xe3,0xcc,0xef,0xbf,0x3f,0x02,0x82,0x00,0x00,0x00,
 0x14,0xde,0x52,0x45,0x45,0x41,0x88,0xaa,0xaa,0x2a,0x0c,0x66,0x00,0x00,0x00,
 0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0xec,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x03,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x1c,0xc0,0x01,0x00,0x0f,0xc0,0x03,0x07,0x08,0xe8,0xe0,0x01,0x00,0x00,0x00,
 0x38,0x80,0x01,0x00,0x06,0x60,0x01,0x06,0x0c,0xcc,0x80,0x01,0x00,0x00,0x00,
 0x40,0x08,0x09,0x12,0x89,0x20,0x10,0x24,0x00,0x80,0x00,0x41,0x82,0x20,0x00,
 0x00,0xbf,0x9f,0xdf,0xef,0xfb,0xf9,0x7f,0x8e,0x8f,0x1e,0xf9,0xff,0xf9,0x00,
 0x00,0x32,0xf3,0x78,0x3e,0x26,0xcc,0xcc,0x08,0x88,0x06,0xb1,0x3d,0x8f,0x01,
 0x00,0xbe,0x61,0x30,0x74,0x27,0x86,0x85,0x08,0x88,0x03,0x91,0x14,0x05,0x01,
 0x00,0x2b,0xe1,0x20,0xbc,0x22,0x86,0x44,0x08,0x88,0x07,0xb1,0x1c,0x07,0x03,
 0x00,0xb3,0xf1,0x70,0x3c,0x24,0xec,0x85,0x08,0x88,0x0c,0xb1,0x1c,0x8f,0x01,
 0x00,0xff,0xbf,0xdf,0xff,0xff,0xf9,0xef,0x7f,0xe8,0xfc,0xbf,0xbd,0xff,0x01,
 0x00,0xaa,0x0a,0x8a,0x8a,0x52,0x01,0xab,0x2a,0x88,0x54,0x25,0xa9,0x52,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x01,0x00,0x0c,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x00,0x80,0x07,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x41,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xc1,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x81,0x00,0x00,0x00,
 0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x81,0x00,0x00,0x00,
 0x10,0x04,0x00,0xca,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x81,0x00,0x00,0x00,
 0x7f,0xfe,0xfb,0xff,0x3f,0xbf,0x8f,0xef,0xe7,0x3f,0x02,0x81,0x00,0x00,0x00,
 0xcc,0x73,0xee,0xd8,0x30,0x16,0x67,0x6d,0xe3,0x19,0x03,0x81,0x01,0x00,0x00,
 0x86,0x21,0xc6,0xcd,0x20,0xb6,0xbd,0x39,0x36,0x8d,0x03,0x81,0x63,0x03,0x00,
 0x84,0x61,0x82,0x5f,0x30,0xb2,0xfd,0x39,0x36,0x06,0x03,0x81,0xf9,0x03,0x00,
 0xc6,0x23,0x82,0xd0,0x30,0xe6,0xf8,0x6c,0x1c,0x13,0x02,0x81,0x00,0x01,0x00,
 0xfe,0xfe,0xdf,0xdf,0xef,0xef,0xd8,0xef,0x9d,0x3f,0x02,0x81,0x00,0x00,0x00,
 0x2c,0x54,0x15,0x85,0x82,0x44,0x90,0x84,0x0c,0x15,0x02,0x81,0x00,0x00,0x00,
 0x02,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x02,0x81,0x00,0x00,0x00,
 0x1f,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x06,0xc1,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x41,0x00,0x00,0x00};



#ifdef AUTOGL_MP

static unsigned char ImageColors[MAX_PIXEL * 3];
static unsigned int ImageDepths[MAX_PIXEL];

static void ReadTaskImage (void)
{
  int scX, scY;
  int pixelId;
  
  pixelId = 0;
  for (scY = 0; scY < ImageHeightSc; scY++) {
    for (scX = 0; scX < ImageWidthSc; scX++) {
      double depth = ZBuffer[scY][scX];

      /* convert from double to unsigned int */
      /* range is about (-5000.0 ... +5000.0), maybe */
      if (depth < 1.0 - (ImageWidthSc + ImageHeightSc) * 10.0) {
	depth = 1.0 - (ImageWidthSc + ImageHeightSc) * 10.0;
      }
      if ((ImageWidthSc + ImageHeightSc) * 10.0 - 1.0 < depth) {
	depth = (ImageWidthSc + ImageHeightSc) * 10.0 - 1.0;
      }
      ImageDepths[pixelId] = (unsigned int)
	(((ImageWidthSc + ImageHeightSc) * 10.0 - depth) * 100.0);

      ImageColors[pixelId * 3 + 0] = ColorBuffer[scY][scX][0];
      ImageColors[pixelId * 3 + 1] = ColorBuffer[scY][scX][1];
      ImageColors[pixelId * 3 + 2] = ColorBuffer[scY][scX][2];
      pixelId++;
    }
  }
}

static void WriteFinalImage (void)
{
  int scX, scY;
  int pixelId;
  
  pixelId = 0;
  for (scY = 0; scY < ImageHeightSc; scY++) {
    for (scX = 0; scX < ImageWidthSc; scX++) {
      /* ignore depth */
      ZBuffer[scY][scX] = -1.0e+30;

      ColorBuffer[scY][scX][0] = ImageColors[pixelId * 3 + 0];
      ColorBuffer[scY][scX][1] = ImageColors[pixelId * 3 + 1];
      ColorBuffer[scY][scX][2] = ImageColors[pixelId * 3 + 2];
      pixelId++;
    }
  }
}

static void MakeFinalImage (void)
{
  ReadTaskImage ();

  if (AutoGL_INSIDE_IsMaster ()) {
    AutoGL_INSIDE_GatherAndComposeImage 
      (ImageWidthSc, ImageHeightSc,
       ImageColors, ImageDepths);
    WriteFinalImage ();
  } else {
    AutoGL_INSIDE_SendTaskImage 
      (ImageWidthSc, ImageHeightSc,
       ImageColors, ImageDepths);
  }
}

#endif



static void InitializeScreen (void)
{
  int scX, scY;

  AutoGL_INSIDE_SetViewRangeDc (ImageWidthSc, ImageHeightSc);

  /*Ｚバッファの初期化 と色の初期化*/
  for (scY = 0; scY < ImageHeightSc; scY++) {
    for (scX = 0; scX < ImageWidthSc; scX++) {
      ZBuffer[scY][scX] = -1.0e+30;
      ColorBuffer[scY][scX][0] 
	= (unsigned char)(View_backgroundRed * 255.0);
      ColorBuffer[scY][scX][1] 
	= (unsigned char)(View_backgroundGreen * 255.0);
      ColorBuffer[scY][scX][2] 
	= (unsigned char)(View_backgroundBlue * 255.0);
    }
  }

  CurrentRed = 1.0;
  CurrentGreen = 1.0;
  CurrentBlue = 1.0;

  View_selectionModeFlag = 0;
}

/*************************************/
/*  ppm save                         */
/*************************************/

static void SaveScreenImageIntoPPM
(char *fileName)
{
  FILE *fp;
  int scX, scY;

#ifdef AUTOGL_MP
  MakeFinalImage ();
#endif

  if (!AutoGL_INSIDE_IsMaster ()) return;

  fp = fopen (fileName, "wb");
  assert(fp != NULL);
  fprintf (fp, "P6\n%d %d\n255\n", ImageWidthSc, ImageHeightSc);
	
  for (scY = ImageHeightSc - 1; 0 <= scY; scY--) {
    for (scX = 0; scX < ImageWidthSc; scX++) {
      fwrite (ColorBuffer[scY][scX], 3, 1, fp);
    }
  }

  fclose (fp);
}



/*
  ２次元上の点が3角形の内部にあるか調べる方法
       p0
       /
      /
     /　p 
    /_________
    p1       p2

  コネクティビティは左周り

  f1(x,y) = (y1 - y0)(x - x0) - (x1 - x0)(y - y0)
  f2(x,y) = (y2 - y1)(x - x1) - (x2 - x1)(y - y1)
  f3(x,y) = (y0 - y2)(x - x2) - (x0 - x2)(y - y2)

  f1 > 0; p0は, 線分p1, p2の左側にある
  f1 = 0; p0は, 線分p1, p2上にある
  f1 < 0; p0は, 線分p1, p2の右側にある
  f1 < 0 && f2 < 0 && f3 < 0  の場合, 外
		
*/

static double GetArea
(double scX0, double scY0,
 double scX1, double scY1,
 double scX2, double scY2)
{
  return ((scX1 - scX0) * (scY2 - scY0) - (scY1 - scY0) * (scX2 - scX0));
}

/* 内部点かどうか? */
static int ContainsPoint
(double scX0, double scY0,
 double scX1, double scY1,
 double scX2, double scY2,
 double scX, double scY)
{
  double area;
  double area0, area1, area2;

  area = GetArea (scX0, scY0, scX1, scY1, scX2, scY2);
  if (0 < area) {
    area0 = GetArea (scX1, scY1, scX2, scY2, scX, scY);
    if (area0 < 0) return 0;
    area1 = GetArea (scX2, scY2, scX0, scY0, scX, scY);
    if (area1 < 0) return 0;
    area2 = GetArea (scX0, scY0, scX1, scY1, scX, scY);
    if (area2 < 0) return 0;
  } else {
    area0 = GetArea (scX1, scY1, scX2, scY2, scX, scY);
    if (0 < area0) return 0;
    area1 = GetArea (scX2, scY2, scX0, scY0, scX, scY);
    if (0 < area1) return 0;
    area2 = GetArea (scX0, scY0, scX1, scY1, scX, scY);
    if (0 < area2) return 0;
  }

  return 1;
}

/* 面積座標で補間 */
static void GetInterpolation
(double scX0, double scY0, double value0,
 double scX1, double scY1, double value1,
 double scX2, double scY2, double value2,
 double scX, double scY,
 double *value_OUT)
{
  double area;
  double area0, area1, area2;

  area = GetArea (scX0, scY0, scX1, scY1, scX2, scY2);
  area0 = GetArea (scX1, scY1, scX2, scY2, scX, scY);
  area1 = GetArea (scX2, scY2, scX0, scY0, scX, scY);
  area2 = GetArea (scX0, scY0, scX1, scY1, scX, scY);
  if (area == 0) { 
    *value_OUT = (value0 + value1 + value2) / 3;
  } else {
    *value_OUT 
      = (value0 * area0 + value1 * area1 + value2 * area2) / area;
  }
}



static void SetPixel
(int ix, int iy, double scZ,
 double red, double green, double blue)
{
  assert(0 <= ix);
  assert(ix < ImageWidthSc);
  assert(0 <= iy);
  assert(iy < ImageHeightSc);

  if (View_selectionModeFlag) {
    if (View_selectionScX - View_selectionRange <= ix
	&& ix <= View_selectionScX + View_selectionRange
	&& View_selectionScY - View_selectionRange <= iy
	&& iy <= View_selectionScY + View_selectionRange) {
      if (View_selectedId == -1
	  || View_selectedScZ < scZ) {
	View_selectedScZ = scZ;
	View_selectedId = View_currentSelectionId;
      }
    }
  } else {
    if (ZBuffer[iy][ix] < scZ) {
      ZBuffer[iy][ix] = scZ;
      
      if (red < 0.0) red = 0.0;
      if (1.0 < red) red = 1.0;
      if (green < 0.0) green = 0.0;
      if (1.0 < green) green = 1.0;
      if (blue < 0.0) blue = 0.0;
      if (1.0 < blue) blue = 1.0;
      
      ColorBuffer[iy][ix][0] = (unsigned char)(red * 255.0);
      ColorBuffer[iy][ix][1] = (unsigned char)(green * 255.0);
      ColorBuffer[iy][ix][2] = (unsigned char)(blue * 255.0);
    }
  }
}

static void DrawLineSc
(double scX0, double scY0, double scZ0,
 double scX1, double scY1, double scZ1)
{
  double scXMin = (scX0 < scX1) ? scX0 : scX1;
  double scXMax = (scX0 < scX1) ? scX1 : scX0;
  double scYMin = (scY0 < scY1) ? scY0 : scY1;
  double scYMax = (scY0 < scY1) ? scY1 : scY0;

  if (scYMax - scYMin < scXMax - scXMin) {
    int ix;

    for (ix = (int)scXMin; ix <= (int)scXMax; ix++){
      if (0 <= ix && ix < ImageWidthSc) {
	double ratio = (ix - scX0 ) / (scX1 - scX0);
	int iy = (int)(scY0 + (scY1 - scY0) * ratio);

	if (0 <= iy && iy < ImageHeightSc) {
	  double scZ = scZ0 + (scZ1 - scZ0) * ratio;

	  SetPixel (ix, iy, scZ, 
		    CurrentRed, CurrentGreen, CurrentBlue);
	}
      }
    }
  } else {
    int iy;

    for (iy = (int)scYMin; iy <= (int)scYMax; iy++){
      if (0 <= iy && iy < ImageHeightSc) {
	double ratio = (iy - scY0 ) / (scY1 - scY0);
	int ix = (int)(scX0 + (scX1 - scX0) * ratio);

	if (0 <= ix && ix < ImageWidthSc) {
	  double scZ = scZ0 + (scZ1 - scZ0) * ratio;
	  
	  SetPixel (ix, iy, scZ, 
		    CurrentRed, CurrentGreen, CurrentBlue);
	}
      }
    }
  }
}

static void DrawTriangleSc
(double scX0, double scY0, double scZ0,
 double scX1, double scY1, double scZ1,
 double scX2, double scY2, double scZ2,
 double red, double green, double blue)
{
  double scXMin, scYMin;
  double scXMax, scYMax;
  int ixMin, ixMax;
  int iyMin, iyMax;
  int ix, iy;
  
  scXMin = (scX0 < scX1) ? scX0 : scX1;
  scXMin = (scXMin < scX2) ? scXMin : scX2;
  scXMax = (scX0 < scX1) ? scX1 : scX0;
  scXMax = (scXMax < scX2) ? scX2 : scXMax;
  scYMin = (scY0 < scY1) ? scY0 : scY1;
  scYMin = (scYMin < scY2) ? scYMin : scY2;
  scYMax = (scY0 < scY1) ? scY1 : scY0;
  scYMax = (scYMax < scY2) ? scY2 : scYMax;

  ixMin = (scXMin < 0) ? 0 : (int)scXMin;
  ixMax = (ImageWidthSc <= scXMax) ? (ImageWidthSc - 1) : (int)scXMax;
  iyMin = (scYMin < 0) ? 0 : (int)scYMin;
  iyMax = (ImageHeightSc <= scYMax) ? (ImageHeightSc - 1) : (int)scYMax;

  for (iy = iyMin; iy <= iyMax; iy++){
    for (ix = ixMin; ix <= ixMax; ix++){
      if (ContainsPoint 
	  (scX0, scY0, 
	   scX1, scY1, 
	   scX2, scY2, 
	   ix, iy)) {
	double scZ;
	
	GetInterpolation 
	  (scX0, scY0, scZ0, 
	   scX1, scY1, scZ1, 
	   scX2, scY2, scZ2, 
	   ix, iy, 
	   &scZ);
	SetPixel (ix, iy, scZ, 
		  red, green, blue);
      }
    } 
  }
}

static void DrawColorInterpolatedTriangleSc
(double scX0, double scY0, double scZ0, 
 double red0, double green0, double blue0,
 double scX1, double scY1, double scZ1, 
 double red1, double green1, double blue1,
 double scX2, double scY2, double scZ2, 
 double red2, double green2, double blue2)
{
  double scXMin, scYMin;
  double scXMax, scYMax;
  int ixMin, ixMax;
  int iyMin, iyMax;
  int ix, iy;

  scXMin = (scX0 < scX1) ? scX0 : scX1;
  scXMin = (scXMin < scX2) ? scXMin : scX2;
  scXMax = (scX0 < scX1) ? scX1 : scX0;
  scXMax = (scXMax < scX2) ? scX2 : scXMax;
  scYMin = (scY0 < scY1) ? scY0 : scY1;
  scYMin = (scYMin < scY2) ? scYMin : scY2;
  scYMax = (scY0 < scY1) ? scY1 : scY0;
  scYMax = (scYMax < scY2) ? scY2 : scYMax;

  ixMin = (scXMin < 0) ? 0 : (int)scXMin;
  ixMax = (ImageWidthSc <= scXMax) ? (ImageWidthSc - 1) : (int)scXMax;
  iyMin = (scYMin < 0) ? 0 : (int)scYMin;
  iyMax = (ImageHeightSc <= scYMax) ? (ImageHeightSc - 1) : (int)scYMax;

  for (iy = iyMin; iy <= iyMax; iy++){
    for (ix = ixMin; ix <= ixMax; ix++){
      if (ContainsPoint 
	  (scX0, scY0, 
	   scX1, scY1, 
	   scX2, scY2, 
	   ix, iy)) {
	double scZ;
	double red, green, blue;
	
	GetInterpolation 
	  (scX0, scY0, scZ0, 
	   scX1, scY1, scZ1, 
	   scX2, scY2, scZ2, 
	   ix, iy, 
	   &scZ);

	GetInterpolation 
	  (scX0, scY0, red0, 
	   scX1, scY1, red1, 
	   scX2, scY2, red2, 
	   ix, iy, 
	   &red);
	GetInterpolation 
	  (scX0, scY0, green0, 
	   scX1, scY1, green1, 
	   scX2, scY2, green2, 
	   ix, iy, 
	   &green);
	GetInterpolation 
	  (scX0, scY0, blue0, 
	   scX1, scY1, blue1, 
	   scX2, scY2, blue2, 
	   ix, iy, 
	   &blue);

	SetPixel (ix, iy, scZ, 
		  red, green, blue);
      }
    } 
  }
}

static void DrawIntensityInterpolatedTriangleSc
(double scX0, double scY0, double scZ0, double intensity0,
 double scX1, double scY1, double scZ1, double intensity1,
 double scX2, double scY2, double scZ2, double intensity2, 
 double red, double green, double blue)
{
  double scXMin, scYMin;
  double scXMax, scYMax;
  int ixMin, ixMax;
  int iyMin, iyMax;
  int ix, iy;
  
  scXMin = (scX0 < scX1) ? scX0 : scX1;
  scXMin = (scXMin < scX2) ? scXMin : scX2;
  scXMax = (scX0 < scX1) ? scX1 : scX0;
  scXMax = (scXMax < scX2) ? scX2 : scXMax;
  scYMin = (scY0 < scY1) ? scY0 : scY1;
  scYMin = (scYMin < scY2) ? scYMin : scY2;
  scYMax = (scY0 < scY1) ? scY1 : scY0;
  scYMax = (scYMax < scY2) ? scY2 : scYMax;

  ixMin = (scXMin < 0) ? 0 : (int)scXMin;
  ixMax = (ImageWidthSc <= scXMax) ? (ImageWidthSc - 1) : (int)scXMax;
  iyMin = (scYMin < 0) ? 0 : (int)scYMin;
  iyMax = (ImageHeightSc <= scYMax) ? (ImageHeightSc - 1) : (int)scYMax;

  for (iy = iyMin; iy <= iyMax; iy++){
    for (ix = ixMin; ix <= ixMax; ix++){
      if (ContainsPoint 
	  (scX0, scY0, 
	   scX1, scY1, 
	   scX2, scY2, 
	   ix, iy)) {
	double scZ;
	double intensity;
	
	GetInterpolation 
	  (scX0, scY0, scZ0, 
	   scX1, scY1, scZ1, 
	   scX2, scY2, scZ2, 
	   ix, iy, 
	   &scZ);
	GetInterpolation 
	  (scX0, scY0, intensity0, 
	   scX1, scY1, intensity1, 
	   scX2, scY2, intensity2, 
	   ix, iy, 
	   &intensity);
	
	SetPixel (ix, iy, scZ, 
		  red * intensity, 
		  green * intensity, 
		  blue * intensity);
      }
    } 
  }
}

static void GetDcOfVc 
(double *dcX_OUT, double *dcY_OUT, double *dcZ_OUT,
 double vcX, double vcY, double vcZ)
{
  double size = AutoGL_GetViewSize ();
  int sizeDc = AutoGL_GetViewSizeDc ();

  *dcX_OUT = vcX / size * sizeDc;
  *dcY_OUT = vcY / size * sizeDc;
  *dcZ_OUT = vcZ / size * sizeDc;
}

static void GetVcOfPosition 
(double *vcX_OUT, double *vcY_OUT, double *vcZ_OUT,
 double x, double y, double z)
{
  double centerX, centerY, centerZ;
  double zAxisX, zAxisY, zAxisZ;
  double upX, upY, upZ;
  double xAxisX, xAxisY, xAxisZ;
  double yAxisX, yAxisY, yAxisZ;
  double offsetX, offsetY, offsetZ;

  AutoGL_GetViewCenter (&centerX, &centerY, &centerZ);
  AutoGL_GetViewDirection (&zAxisX, &zAxisY, &zAxisZ);
  AutoGL_GetViewUpVector (&upX, &upY, &upZ);

  AutoGL_GetVectorProduct3D (&xAxisX, &xAxisY, &xAxisZ,
			     upX, upY, upZ,
			     zAxisX, zAxisY, zAxisZ);
  AutoGL_NormalizeVector3D (&xAxisX, &xAxisY, &xAxisZ,
			    xAxisX, xAxisY, xAxisZ);
  
  AutoGL_GetVectorProduct3D (&yAxisX, &yAxisY, &yAxisZ,
			     zAxisX, zAxisY, zAxisZ, 
			     xAxisX, xAxisY, xAxisZ);
  AutoGL_NormalizeVector3D (&yAxisX, &yAxisY, &yAxisZ,
			    yAxisX, yAxisY, yAxisZ);
  
  AutoGL_SubtractVector3D (&offsetX, &offsetY, &offsetZ,
			   x, y, z,
			   centerX, centerY, centerZ);
  AutoGL_AssignVector3D 
    (vcX_OUT, vcY_OUT, vcZ_OUT,
     xAxisX * offsetX + xAxisY * offsetY + xAxisZ * offsetZ,
     yAxisX * offsetX + yAxisY * offsetY + yAxisZ * offsetZ,
     zAxisX * offsetX + zAxisY * offsetY + zAxisZ * offsetZ);
}

static void GetScOfPosition 
(double *scX_OUT, double *scY_OUT, double *scZ_OUT,
 double x, double y, double z)
{
  double vcX, vcY, vcZ;
  double dcX, dcY, dcZ;
  int widthDc, heightDc;

  AutoGL_GetViewRangeDc 
    (&widthDc, &heightDc);

  GetVcOfPosition (&vcX, &vcY, &vcZ,
		   x, y, z);
  GetDcOfVc (&dcX, &dcY, &dcZ,
	     vcX, vcY, vcZ);

  *scX_OUT = dcX + widthDc / 2;
  *scY_OUT = dcY + heightDc / 2;
  *scZ_OUT = dcZ;
}



void AutoGL_SetTwoSideFaceFlag (int flag)
{
  /* do nothing */
}

int AutoGL_GetTwoSideFaceFlag (void)
{
  /* default setting is yes */
  /* user do not have to care about it */
  return 1;
}

void AutoGL_SetBackgroundColor 
(double red, double green, double blue)
{
  View_backgroundRed = red;
  View_backgroundGreen = green;
  View_backgroundBlue = blue;
}

void AutoGL_INSIDE_StartDrawingOffScreenWindow (void)
{
  InitializeScreen ();
}

void AutoGL_INSIDE_EndDrawingOffScreenWindow (void)
{
  char fileName[1024];

  AutoGL_GetImageFileName 
    (fileName);
  SaveScreenImageIntoPPM (fileName);
}

void AutoGL_INSIDE_ResizeOffScreenWindow (int widthDc, int heightDc)
{
  assert(widthDc <= MAX_IMAGE_WIDTH);
  assert(heightDc <= MAX_IMAGE_HEIGHT);
  
  ImageWidthSc = widthDc;
  ImageHeightSc = heightDc;
}

void AutoGL_SetColor2 
(float red, float green, float blue)
{
  CurrentRed = red;
  CurrentGreen = green;
  CurrentBlue = blue;
}

void AutoGL_DrawLine2 
(float x0, float y0, float z0,
 float x1, float y1, float z1)
{
  double scX0, scY0, scZ0;
  double scX1, scY1, scZ1;
  
  GetScOfPosition (&scX0, &scY0, &scZ0,
		   x0, y0, z0);
  GetScOfPosition (&scX1, &scY1, &scZ1,
		   x1, y1, z1);
  DrawLineSc (scX0, scY0, scZ0, 
	      scX1, scY1, scZ1);
}

void AutoGL_DrawTriangle2 
(float x0, float y0, float z0,
 float x1, float y1, float z1,
 float x2, float y2, float z2,
 float nx, float ny, float nz)
{
  double dirX, dirY, dirZ;
  double intensity;
  double scX0, scY0, scZ0;
  double scX1, scY1, scZ1;
  double scX2, scY2, scZ2;
  
  AutoGL_GetViewDirection (&dirX, &dirY, &dirZ);
  intensity = fabs (nx * dirX + ny * dirY + nz * dirZ);
  intensity = 0.2 + intensity * 0.8;
  
  GetScOfPosition (&scX0, &scY0, &scZ0,
		   x0, y0, z0);
  GetScOfPosition (&scX1, &scY1, &scZ1,
		   x1, y1, z1);
  GetScOfPosition (&scX2, &scY2, &scZ2,
		   x2, y2, z2);
  DrawTriangleSc 
    (scX0, scY0, scZ0, 
     scX1, scY1, scZ1,
     scX2, scY2, scZ2,
     CurrentRed * intensity,
     CurrentGreen * intensity,
     CurrentBlue * intensity);
}

void AutoGL_DrawColorInterpolatedTriangle2
(float x0, float y0, float z0, float red0, float green0, float blue0,  
 float x1, float y1, float z1, float red1, float green1, float blue1,  
 float x2, float y2, float z2, float red2, float green2, float blue2,
 float nx, float ny, float nz)
{
  double dirX, dirY, dirZ;
  double intensity;
  double scX0, scY0, scZ0;
  double scX1, scY1, scZ1;
  double scX2, scY2, scZ2;

  AutoGL_GetViewDirection (&dirX, &dirY, &dirZ);
  intensity = fabs (nx * dirX + ny * dirY + nz * dirZ);
  intensity = 0.2 + intensity * 0.8;
  
  GetScOfPosition (&scX0, &scY0, &scZ0,
		   x0, y0, z0);
  GetScOfPosition (&scX1, &scY1, &scZ1,
		   x1, y1, z1);
  GetScOfPosition (&scX2, &scY2, &scZ2,
		   x2, y2, z2);
  DrawColorInterpolatedTriangleSc 
    (scX0, scY0, scZ0, 
     red0 * intensity, green0 * intensity, blue0 * intensity, 
     scX1, scY1, scZ1, 
     red1 * intensity, green1 * intensity, blue1 * intensity,
     scX2, scY2, scZ2, 
     red2 * intensity, green2 * intensity, blue2 * intensity);
}

void AutoGL_DrawNormalInterpolatedTriangle2 
(float x0, float y0, float z0, float nx0, float ny0, float nz0,
 float x1, float y1, float z1, float nx1, float ny1, float nz1,
 float x2, float y2, float z2, float nx2, float ny2, float nz2)
{
  double dirX, dirY, dirZ;
  double intensity0, intensity1, intensity2;
  double scX0, scY0, scZ0;
  double scX1, scY1, scZ1;
  double scX2, scY2, scZ2;

  AutoGL_GetViewDirection (&dirX, &dirY, &dirZ);
  intensity0 = fabs (nx0 * dirX + ny0 * dirY + nz0 * dirZ);
  intensity0 = 0.2 + intensity0 * 0.8;
  intensity1 = fabs (nx1 * dirX + ny1 * dirY + nz1 * dirZ);
  intensity1 = 0.2 + intensity1 * 0.8;
  intensity2 = fabs (nx2 * dirX + ny2 * dirY + nz2 * dirZ);
  intensity2 = 0.2 + intensity2 * 0.8;
  
  GetScOfPosition (&scX0, &scY0, &scZ0,
		   x0, y0, z0);
  GetScOfPosition (&scX1, &scY1, &scZ1,
		   x1, y1, z1);
  GetScOfPosition (&scX2, &scY2, &scZ2,
		   x2, y2, z2);
  DrawIntensityInterpolatedTriangleSc 
    (scX0, scY0, scZ0, intensity0,
     scX1, scY1, scZ1, intensity1,
     scX2, scY2, scZ2, intensity2,
     CurrentRed, CurrentGreen, CurrentBlue);
}

void AutoGL_DrawString2 
(float x, float y, float z,
 const char *str)
{
  double scX, scY, scZ;
  int len = strlen (str);
  int ich;
  
  GetScOfPosition (&scX, &scY, &scZ,
		   x, y, z);
  
  for (ich = 0; ich < len; ich++) {
    int ch = str[ich];
    int width = 7;
    int height = 14;
    int pixelx = ch % 16 * width;
    int pixely = ch / 16 * height;
    int ix, iy;
    
    for (iy = 0; iy < height; iy++) {	  
      int bytey = pixely + iy + 1;
      
      for (ix = 0; ix < width; ix++) {
	int bytex = (pixelx + ix + 1) / 8;
	int bitx = (pixelx + ix + 1) % 8;
	char bit = autogl_font_bits[bytey * 15 + bytex];
	int flag;
	
	switch (bitx) {
	case 0:  flag = bit & 0x01;  break;
	case 1:  flag = bit & 0x02;  break;
	case 2:  flag = bit & 0x04;  break;
	case 3:  flag = bit & 0x08;  break;
	case 4:  flag = bit & 0x10;  break;
	case 5:  flag = bit & 0x20;  break;
	case 6:  flag = bit & 0x40;  break;
	case 7:  flag = bit & 0x80;  break;
	}
	
	if (flag) {
	  int ixx = (int)scX + ix + ich * width;
	  int iyy = (int)scY - iy;

	  if (0 <= ixx && ixx < ImageWidthSc
	      && 0 <= iyy && iyy < ImageHeightSc) {
	    SetPixel (ixx, iyy, scZ,
		      CurrentRed, CurrentGreen, CurrentBlue);
	  }
	}
      }
    }
  }
}

void AutoGL_StartSelection (int x, int y, int range)
{
  assert(!View_selectionModeFlag);

  View_selectionModeFlag = 1;
  View_selectionScX = x + ImageWidthSc / 2;
  View_selectionScY = y + ImageHeightSc / 2;
  View_selectionRange = range;
  View_currentSelectionId = -1;
  View_selectedId = -1;
  View_selectedScZ = 0.0;
}

void AutoGL_SetSelectionId2 (int id)
{
  assert(0 <= id);

  if (View_selectionModeFlag) {
    View_currentSelectionId = id;
  }
}

void AutoGL_EndSelection (void)
{
  assert(View_selectionModeFlag);

  View_selectionModeFlag = 0;
}

int AutoGL_GetSelectedId (void)
{
  int result = View_selectedId;

#ifdef AUTOGL_MP
  {
    int minZ = (int)(1000000.0 - View_selectedScZ * 100.0);

    result = AutoGL_INSIDE_GatherSelectedId (result, minZ);
  }
#endif

  return result;
}

void AutoGL_BeginNativeCall (void)
{
  /* do nothing */
}

void AutoGL_EndNativeCall (void)
{
  /* do nothing */
}



/* Not Implemented Yet */

void AutoGL_TurnOnSpecular (void)
{
  /* NEED TO REDEFINE */
  /* not implemented yet */
}

void AutoGL_TurnOnTransparency (void)
{
  /* NEED TO REDEFINE */
  /* not implemented yet */
}

void AutoGL_SetOpacity (double opacity)
{
  /* NEED TO REDEFINE */
  /* not implemented yet */
}

void AutoGL_GetViewImage
(unsigned char image_OUT[])
{
  /* NEED TO REDEFINE */
  /* not implemented yet */
}







/* To Be Obsolate */

void AutoGL_SetTextureMap (int sizeLevel, const unsigned char image[])
{
  /* NEED TO REDEFINE */
  /* not implemented yet */
}

void AutoGL_DrawTexturedTriangle 
(double x0, double y0, double z0,
 double x1, double y1, double z1,
 double x2, double y2, double z2,
 double scaleFactor)
{
  /* NEED TO REDEFINE */
  /* not implemented yet */
}

void AutoGL_DrawImage 
(double x, double y, double z,
 int widthDc, int heightDc, const unsigned char image[])
{
  /* NEED TO REDEFINE */
  /* not implemented yet */
}

